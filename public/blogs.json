[
  {
    "blog_title": "Book Review (JavaScript: The Good Parts by Douglas Crockford)",
    "blog_date": "Sun Jul 30 2017 @ 15:00",
    "blog_photo": "javascript_the_good_parts_cover.png",
    "blog_text": "<div><span style=\"white-space: normal;\">This is a partial review of <a href=\"https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742\">JavaScript: The Good Parts</a>, as I'm currently on chapter 7 (Regular Expressions).</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 1 - Good Parts</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">This is a <i>very</i> brief chapter in which Douglas makes the point that <u>no</u> programming language is perfect - you (<i>as a developer</i>) ultimately need to decide which aspects are worth using and which are not. Of course, as with using any tool skillfully, this requires time and experience in order to develop the ability to make these judgement calls - or a guide (like this book).</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">The rest of the chapter discusses some of the <u>good</u> and <u>bad</u> parts of JavaScript (such as <i>object literal notation</i> and the <i>global object</i>, respectively), while making the point that a lot of the \"issues\" with JavaScript are actually with the Document Object Module (DOM) and not JavaScript itself.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Finally, to answer \"<i>why JavaScript?</i>\" - it's because it's the language of the Web. Java had its shot back in the day (and failed) while JavaScript succeeded, so avoiding JavaScript is not really an option. And since it's <i>very</i> easy to write (bad) JavaScript, it's important to make the time to become adept in reading and writing it.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 2 - Grammar</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">This chapter provides a brief overview of the grammar of the <u>good parts</u> of JavaScript - specifically:</span></div><div><ul><li>whitespace and comments (// <i>preferred</i>)<br></li><li>names (<i>rules, reserved words</i>)<br></li><li>numbers (<i>single 64-bit floating point type</i>)<br></li><li>strings (<i>quotes, escape character, immutable property</i>)<br></li><li>statements (<i>expression, conditional, looping, disruptive</i>)<br></li><li>expressions<br></li><li>literals (<i>number, string, object, array, function, regexp</i>)<br></li><li>functions<br></li></ul></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 3 - Objects</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">This chapter discusses <u>objects</u> (arrays, functions, regular expressions and object literals), including:</span></div><div><ul><li>how to create an object<br></li><li>property aspects<br></li><li>retrieving values<br></li><li>updating an object<br></li><li>reference (<i>objects are never copied</i>)<br></li><li>prototype (<i>Object.prototype, prototype link</i>)<br></li><li>reflection (<i>inspecting objects</i>)<br></li><li>enumeration (<i>for in [no guaranteed order], for</i>)<br></li><li>deleting properties<br></li><li>global (object) variable to deal with global scope<br></li></ul></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 4 - Functions</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">This chapter discussed a number of function concepts that were familiar (return values, scope), some that I've recently started using (closure, callbacks), and a number that I <b>really</b> need to go back to and play with more in order to develop a better understanding (module, cascade, curry, memoization).</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 5 - Inheritance</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">The Inheritance chapter starts off with providing a \"pseudoclassical\" approach to JavaScript and how one might develop using a typical \"classes\" approach, then discusses the downsides of doing so (such as composing hierarchies that are unnecessarily deep and complicated).</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Douglas then rewrites the previous example using prototypal inheritance and the functional pattern in order to show the benefit of doing things in a more \"natural\" way for the language.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Chapter 6 - Arrays</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">After the Functions and Inheritance chapters (which contained a <u>lot</u> of new concepts), this chapter was <i>very</i> reassuring. Arrays in JavaScript have some differences from other languages (for example, an array's length is not an upper bound), but otherwise the aspects (such as deleting elements, enumerating, methods) are pretty familiar.</span></div>"
  },
  {
    "blog_title": "The Joys of Prototyping",
    "blog_date": "Thu Aug 10 2017 @ 21:50",
    "blog_photo": "prototypes.png",
    "blog_text": "<div><span style=\"white-space: normal;\">You were just assigned to a project that requires tech which you have never used, and quite possibly have never even heard of. So what can you do to start being productive as quickly as possible? One word - prototype.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>What is a Prototype?</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">According to <a href=\"https://en.wikipedia.org/wiki/Prototype\">Wikipedia</a>, a prototype is \"an early sample, model, or release of a product built to test a concept or process\". Additionally, \"it is important to realize that by their very definition, prototypes will represent some compromise from the final production design\".</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">In other words (<i>and specific to software development</i>), a prototype is a program that lets you develop as little or as much as you need to, in order to become familiar with and verify how some tech works. A prototype can be as small as a single method or as sophisticated as you want, with the ultimate goal to develop a deeper understanding of how something works.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Why Prototype?</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">So you might ask - why bother taking the time to prototype? Wouldn't it be faster to get some examples and start working them into the production code?</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Well, I can't claim to be an expert (based on how long I've been developing), but here are some points that I feel are worth strong consideration:</span></div><div><ol><li><i>A prototype is <u>pure</u>.</i></li><li><i>A prototype is <u>flexible</u>.</i></li><li><i>A prototype is your <u>sandbox</u> to play and learn.</i></li><li><i>Troubleshooting is <u>much</u> easier.</i></li><li><i>Integration of working prototype code is <u>much</u> easier.</i></li></ol></div><div><span style=\"white-space: normal;\">In a prototype the code can be reduced to only what is absolutely necessary, so dependencies and relationships are less likely to be obscured or influenced by other functions and features. You can experiment with different approaches and solutions as you are learning how things work and make sweeping changes without risk to the larger project.</span><br></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">And I may be speaking for myself here, but I <u>learn</u> best by playing with code - not by reading or watching videos, although those are invaluable when researching while getting started and troubleshooting.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>A Practical Example</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Not too long ago, I was assigned to a project that was storing files in a database. The approach worked well enough during testing, but based on prior research and experience I advised against this approach. Fair enough, the team agreed that files would be stored elsewhere - in an AWS S3 bucket. And I was tasked with putting them there and rewriting all of the logic currently writing them to a database.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Now at this point, I had not even <i>heard</i> of an S3 bucket, let alone know how to write files to one and read them back. And the present JavaScript and Ruby code involved with translating and saving the files involved a traversal of no less than three databases (PouchDB, Cloudant, PostgreSQL). &nbsp;So where to begin?</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">First, of course, was research and I found Amazon's guides to be a decent start. &nbsp;The greatest hurdle (<i>as usual</i>) was figuring out what the keywords and terms were, so that I could focus my searches and find practical examples that came close to what I was attempting to do.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Once I had figured out how to (1) create an S3 bucket, (2) create an IAM user limited to accessing the bucket and (3) obtain the credentials necessary to access the bucket programmatically, I was ready to start prototyping.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">I began with trying to connect to S3 and getting a response. &nbsp;After <u>finally</u> getting that right, I worked on listing all of the S3 buckets (<i>just to verify the connection</i>). &nbsp;Then on to listing files in the bucket (<i>after manually uploading them through the Amazon S3 web console</i>). &nbsp;Then programmatically uploading a file to the bucket. &nbsp;And finally with reading a file from the bucket via a secure URL (<i>that expired after a short period of time</i>).</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Every step involved a fair amount of research and playing in the sandbox, and the prototype itself is no great masterpiece. &nbsp;But it works and allowed me to integrate the necessary logic <u>much</u> more easily into the larger project.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\"><font size=\"4\"><b>Final Thoughts</b></font></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">If you haven't considered using prototypes before, hopefully this article will give you some solid reasons why you should. &nbsp;In the past two months, I've developed at least a dozen prototypes. &nbsp;And rather than being a time-sink, they have saved me countless hours and have allowed me learn a lot in a relatively short period of time. &nbsp;I sincerely hope they can do the same for you.</span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">And for anyone interested, here is the GitHub repository for the AWS S3 bucket prototype:</span></div><div><span style=\"white-space: normal;\"><a href=\"https://github.com/jverbosky/aws_s3_bucket\">https://github.com/jverbosky/aws_s3_bucket</a></span></div><div><span style=\"white-space: normal;\"><br></span></div><div><span style=\"white-space: normal;\">Details for running the app are included in the README.md file.</span></div>"
  },
  {
    "blog_title": "OOP or How I Learned to Love Classes",
    "blog_date": "Wed Aug 16 2017 @ 23:44",
    "blog_text": "<div><div>My introduction to object-oriented programming were through a few animals and the sounds they make. Based on a <a href=\"https://www.google.com/search?q=programming+classes+animal+sounds\">quick web search</a>, this appears to be a popular way to introduce the different concepts such as classes, methods and instance variables.</div><br><div>I then went on to develop a <a href=\"https://github.com/jverbosky/tic_tac_toe_ai_n\">tic tac toe game</a> using classes, and while I started to understand <i>how</i> to use them, I have to be honest and admit that I didn't <b>truly</b> understand <i>when</i> or <i>why</i> to use them<br><br></div><div>So I researched and ultimately found two excellent books that started to open up my horizons:</div><div><ul><li><a href=\"http://www.poodr.com/\">Practical Object-Oriented Design in Ruby</a> by Sandi Metz<br></li><li><a href=\"http://designpatternsinruby.com/\">Design Patterns in Ruby</a> by Russ Olsen</li></ul></div><div>Again, though, I'll be honest and admit that even after reading these books, I continued using the same approach of writing a long block of functions, waiting for some animal sound or bicycle part opportunity to come along.<br></div><div><b><font size=\"4\"><br></font></b></div><div><b><font size=\"4\">The Aha Moment</font></b><br><br></div><div>Fortunately, something did come along and my first thought to use a class (instead of a block of functions) was simply as a way to contain the data flow (from the receiving function to the final output function), almost like putting them all in a box or a bubble. To be perfectly frank, I was trying to avoid the \"trouble\" of creating a process queue (since I had never done so before) - but more on that later.<br><br></div><div>A little background - an app I was working on had to send a series of \"reports\" to a Sinatra server, which would then do various things with them (such as parsing text, saving images, writing data to a database, and performing verification and clean up). The number of these reports could vary and range from 2 to 20+.<br><br></div><div>Dealing with 2 was fine and they flew through my functions with ease. But later on, when testing with 10 reports and with larger images, random database writes and image saves would end up getting dropped.  After some logging to the terminal, I determined that this was due to certain functions taking a while to process all of the reports that were flying in to the Sinatra server.<br></div></div><div><br>I thought, \"<i>maybe if I could send each report through the functions and not worry about all of these calls coming in at once</i>\" - and that was when I through of wrapping them in a class. Doing so was <u>not</u> the ultimate answer, but it <i>was</i> a step towards it. Pushing numerous reports to the Sinatra server, performance was improved as (just as I had imagined) each report was handled in its own \"bubble of functions\" (or, more formally, its own dedicated object with its own memory space).<br></div><div><br>To get everything working as dependably and efficiently as possible, I ultimately did implement a queue (as a singleton class - inspired by the Design Patterns in Ruby book) to ensure that reports could fly in, line up and then get processed one-by-one, and the report handling is working fine.<br><b><font size=\"4\"><br></font></b></div><div><font style=\"\" size=\"4\"><b>Everything Clicks</b></font><br><br></div><div>Shortly thereafter, another challenge came along that basically said, \"<i>yeah, you aren't going to solve this one without classes...</i>\".<br><br>I present to you a <a href=\"https://portfolio-jv.herokuapp.com/json\">simplified version</a> of the baseline JSON file for which I needed to do the following:<br><ul><li>pull all unique values to populate corresponding category-level drop-downs</li><li>add and delete values at any level</li></ul>Additional challenges included the following:<br><ul><li>some mid-level values were empty</li><li>a high amount of repetition for values</li></ul>And for a final challenge - there would ultimately be multiple JSON files using the same format, and once the proper one was specified it had to be loaded with the app able to meet all of the requirements.<br><b><font size=\"4\"><br></font></b></div><div><font style=\"\" size=\"4\"><b>Breaking it Down</b></font><br><br></div><div>Although I developed everything kind of organically (i.e. little by little), I ultimately ended up with the following classes:<br><ul><li><u>SetCriteria</u><br></li><ul><li>a singleton class to specify the criteria that would decide which JSON to use</li></ul><li><u>ReadJson</u><br></li><ul><li>a class to specify the path to the JSON and open it for reading</li><li>relies on <u>SetCriteria</u> instance variables</li></ul><li><u>S1Updater</u>, <u>S3Updater</u></li><ul><li>classes to handle updating the simpler first and last sections of the JSON file</li><li>rely on <u>ReadJson</u> instance variables</li></ul><li><u>S2Parser</u></li><ul><li>a class to parse out the raw keys and values for each level of the deeply nested section</li><li>also relies on <u>ReadJson</u> instance variables</li></ul><li><u>S2Filter</u></li><ul><li>a class to filter out the unique values for each level to populate drop-downs</li><li>relies on <u>S2Parser</u> instance variables</li></ul><li><u>S2Addresser</u></li><ul><li>a class to assign a unique address to every item in the deeply nested section, done to mitigate all of the repeated keys and values</li><li>also relies on <u>S2Parser</u> instance variables</li></ul><li><u>S2Compare</u></li><ul><li>a class to determine if user-specified deletion targets exist in the JSON</li><li>relies on <u>S2Addresser</u> instance variables</li></ul><li><u>S2Updater</u></li><ul><li>a class to handle merging new values and pruning existing values</li><li>relies on <u>S2Compare</u> instance variables</li></ul></ul><b><font size=\"4\">Why Classes?</font></b><br><br>So why did I feel I needed (or at least, could benefit from) using classes here? Well, there are a few reasons:<br><b><br></b></div><div><b>1. Data encapsulation</b><br><br></div><div>Big word that basically means that you are wrapping all of your functions and variables in a \"bubble\". Each time you create a new instance of your class, the \"bubble\" does its thing for the data it is given and then pops out of existence. You get to choose the data that each class can receive, how to transform and store that data, and what data is shared with other parts of the program.<br><b><br></b></div><div><b>2. Sharing data within a class </b>(via instance variables)<br><br></div><div>Instance variables are basically \"global variables\" for all of the methods (functions) within the class. In other words, I can update and access these variables from any of the methods in the class without having to pass them in as arguments (which can be tedious and hard to follow after a while).<br><b><br></b></div><div><b>3. Sharing data between classes</b> (via <i>attr_accessor</i> and <i>attr_reader</i>)<br><br></div><div>If you look at the list of classes again, you'll see that the output from ReadJson is being used by three other classes (<u>S1Updater</u>, <u>S2Parser</u>, <u>S3Updater</u>) and that the output from <u>S2Parser</u> is being used by two other classes (<u>S2Filter</u>, <u>S2Addresser</u>). This is one of the major benefits of using classes - once you have a useful output, you can use it anywhere you need it.<br><br></div><div>Ultimately, these benefits allowed me to break things down into smaller and smaller chunks, until things were at a level that was manageable. And believe it or not, <i>it was fun</i>!</div>"
  },
  {
    "blog_title": "Getting Ruby Puts Statements to Appear in Heroku Web App Logging",
    "blog_date": "Wed Aug 30 2017 @ 22:58",
    "blog_photo": "puts_output.png",
    "blog_text": "<div><div>Being able to log values to the terminal is absolutely essential when troubleshooting software. With Ruby, we can use \"puts\" and \"p\" statements to determine the exact values of the variables we are working with, and it is straightforward when running an app locally.</div><div><br></div><div>However, once an app has been deployed to Heroku, the output from these statements don't appear in the application logs (<i>by default</i>). I discovered this not too long ago when an updated app worked fine locally but broke after it was redeployed to Heroku. And without the ability to log values, identifying the underlying issue was a non-starter.</div><br><div>Fortunately, I found a <u>very</u> simple fix to enable the logging in Heroku:</div><br><div>1. Add the following lines to your <i>app.rb</i> file (before any routes):</div><br><div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i># For Heroku logging to work (via Heroku CLI: heroku logs --app your-app-name)</i><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configure do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$stdout.sync = true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></div><br>2. Add any \"puts\" or \"p\" statements where you need visibility (Sinatra routes, Ruby methods, embedded Ruby in views).<br><br></div><div>3. Redeploy the app to Heroku.<br><br></div><div>4. In the Heroku dashboard, click on the app's name to open its <i>Overview </i>screen.<br><br></div><div>5. Select the <b>More</b> button in the upper-right part of the screen.<br><br></div><div>6. Select the <b>View logs</b> option to open the <i>Application Logs </i>screen.<br><br></div><div>7. Launch the Heroku app in a web browser and perform whatever action triggers the \"puts\"/\"p\" statements.<br><br></div><div>8. The output will now appear in the <i>Application Logs </i>screen's output.<br></div><br><div>Here's an <a href=\"https://portfolio-jv.herokuapp.com/herokulog\">example</a> of Heroku logging output for an app. Note that the first half is output without the <i>stdout.sync </i>statement in the route, while the second half is with the statement.</div><br><div>The output from the \"puts\" statements appears in two places:</div><br><div>1. When the app is being rebuilt:<br><br></div><div>2017-08-31T02:50:28.178815+00:00 app[web.1]: This is output from a route...<br>2017-08-31T02:50:28.178815+00:00 app[web.1]: This is output from a method...<br>2017-08-31T02:50:28.178816+00:00 app[web.1]: This is output from a view...<br></div><br><div>2. When the Prototypes page is selected (which is where all of the \"puts\" statements fire off):<br><br>2017-08-31T02:50:46.069933+00:00 app[web.1]: This is output from a route...<br>2017-08-31T02:50:46.070284+00:00 app[web.1]: This is output from a method...<br>2017-08-31T02:50:46.777636+00:00 heroku[router]: at=info method=GET path=\"/prototypes\" host=portfolio-jv.herokuapp.com request_id=fd03b707-89f2-42b8-92c6-e48450115b86 fwd=\"100.6.83.223\" dyno=web.1 connect=1ms service=710ms status=200 bytes=40345 protocol=https<br>2017-08-31T02:50:46.772041+00:00 app[web.1]: This is output from a view...</div><br><div>Hope that helps!</div>"
  }
]
